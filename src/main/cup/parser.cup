package org.automatas.language;

import java_cup.runtime.Symbol;
import java.util.List;
import org.automatas.engine.Ast;
import org.automatas.engine.AstKind;
import org.automatas.engine.Scalar;
import org.automatas.engine.ScalarType;

/* Literals */
terminal Scalar BOOL;
terminal Scalar FLOAT;
terminal Scalar INTEGER;
terminal Scalar IDENTIFIER;
terminal Scalar STRING;

/* Types */
terminal ScalarType TYPENAME_ARRAY;
terminal ScalarType TYPENAME_BOOL;
terminal ScalarType TYPENAME_FLOAT;
terminal ScalarType TYPENAME_INT;
terminal ScalarType TYPENAME_STRING;

/* Logic operators */
terminal DECLARATION, ASSIGN;
terminal EQUALS, NOT_EQUALS;
terminal SMALLER, SMALLER_OR_EQUAL;
terminal GREATER, GREATER_OR_EQUAL;
terminal AND, OR;

/* Arithmetic operators */
terminal PLUS, MINUS, MULTIPLY;
terminal POW, DIVIDE, MODULUS;
terminal INCREMENT, DECREMENT;

/* Keywords */
terminal PRINT, PRINTLN, UNSET, LEN;
terminal TYPEOF, AS, IS, IN, INPUT;
terminal FOR, FOREACH, DO, WHILE;
terminal IF, ELSE;
terminal NOELSE;

/* Symbols */
terminal LPAREN, RPAREN;
terminal LBRACKET, RBRACKET;
terminal LBRACE, RBRACE;
terminal EXCLAMATION;
terminal COMMA, SEMICOLON;

/* Statements */
non terminal List<Ast> statement_list;
non terminal Ast top_statement;
non terminal Ast statement, if_statement, if_stmt_without_else;

/* Expressions */
non terminal List<Ast> print_expr_list, array_expr_value_list;
non terminal Ast expr, array_expr, print_expr, optional_expr;
non terminal Ast scalar, ident, array_access, variable;
non terminal ScalarType type_name;

precedence right DECLARATION, ASSIGN;
precedence left MULTIPLY, POW, DIVIDE, MODULUS;
precedence left PLUS, MINUS;
precedence left AND, OR, AS, IS;

precedence nonassoc EXCLAMATION;
precedence nonassoc EQUALS, NOT_EQUALS;
precedence nonassoc SMALLER, SMALLER_OR_EQUAL;
precedence nonassoc GREATER, GREATER_OR_EQUAL;
precedence nonassoc INCREMENT, DECREMENT;
precedence nonassoc ELSE, LBRACKET, RBRACKET;

start with top_statement;

top_statement ::=
    statement_list:sl                       {: RESULT = Ast.makeFromList(AstKind.AST_STATEMENT_LIST, sl); :}
;

statement_list ::=
    statement_list:sl statement:s           {: sl.add(s); RESULT = sl; :}
  | /* %empty */                            {: RESULT = Ast.makeList(); :}
;

statement ::=
    LBRACE statement_list:sl RBRACE         {: RESULT = Ast.makeFromList(AstKind.AST_STATEMENT_LIST, sl); :}
  | if_statement:i                          {: RESULT = i; :}
  | DO statement:s WHILE expr:e SEMICOLON   {: RESULT = Ast.make(AstKind.AST_DO_WHILE, s, e); :}
  | WHILE expr:e statement:s                {: RESULT = Ast.make(AstKind.AST_WHILE, e, s); :}
  | FOR expr:a SEMICOLON expr:b SEMICOLON expr:c statement:s
                                            {: RESULT = Ast.make(AstKind.AST_FOR, a, b, c, s); :}
  | FOREACH ident:i IN expr:e statement:s   {: RESULT = Ast.make(AstKind.AST_FOREACH, i, e, s); :}
  | PRINT print_expr_list:pel SEMICOLON     {: RESULT = Ast.makeFromList(AstKind.AST_STATEMENT_LIST, pel); :}
  | PRINTLN expr:e SEMICOLON                {: RESULT = Ast.make(AstKind.AST_PRINTLN, e); :}
  | expr:e SEMICOLON                        {: RESULT = e; :}
  | UNSET variable:v SEMICOLON              {: RESULT = Ast.make(AstKind.AST_UNSET, v); :}
;

if_stmt_without_else ::=
    IF expr:e statement:s                   {: RESULT = Ast.make(AstKind.AST_IF, e, s); :}
;

if_statement ::=
    if_stmt_without_else:iswe               {: RESULT = iswe; :} %prec NOELSE
  | if_stmt_without_else:iswe ELSE statement:s
                                            {: RESULT = Ast.make(AstKind.AST_IF_ELSE, iswe, s); :}
;

print_expr_list ::=
    print_expr_list:pel COMMA print_expr:pe {: pel.add(pe); RESULT = pel; :}
  | print_expr:pe                           {: RESULT = Ast.makeList(pe); :}
;

print_expr ::=
    expr:e                                  {: RESULT = Ast.make(AstKind.AST_PRINT, e); :}
;

expr ::=
    variable:v                              {: RESULT = v; :}
  | variable:v DECLARATION expr:e           {: RESULT = Ast.make(AstKind.AST_DECLARATION, v, e); :}
  | variable:v ASSIGN expr:e                {: RESULT = Ast.make(AstKind.AST_ASSIGN, v, e); :}
  | variable:v INCREMENT                    {: RESULT = Ast.make(AstKind.AST_POST_INC, v); :}
  | INCREMENT variable:v                    {: RESULT = Ast.make(AstKind.AST_PRE_INC, v); :}
  | variable:v DECREMENT                    {: RESULT = Ast.make(AstKind.AST_POST_DEC, v); :}
  | DECREMENT variable:v                    {: RESULT = Ast.make(AstKind.AST_PRE_DEC, v); :}
  | expr:a AND expr:b                       {: RESULT = Ast.make(AstKind.AST_AND, a, b); :}
  | expr:a OR expr:b                        {: RESULT = Ast.make(AstKind.AST_OR, a, b); :}
  | expr:a PLUS expr:b                      {: RESULT = Ast.make(AstKind.AST_ADD, a, b); :}
  | expr:a MINUS expr:b                     {: RESULT = Ast.make(AstKind.AST_SUBTRACT, a, b); :}
  | expr:a MULTIPLY expr:b                  {: RESULT = Ast.make(AstKind.AST_MULTIPLY, a, b); :}
  | expr:a POW expr:b                       {: RESULT = Ast.make(AstKind.AST_POW, a, b); :}
  | expr:a DIVIDE expr:b                    {: RESULT = Ast.make(AstKind.AST_DIVIDE, a, b); :}
  | expr:a MODULUS expr:b                   {: RESULT = Ast.make(AstKind.AST_MODULUS, a, b); :}
  | expr:a EQUALS expr:b                    {: RESULT = Ast.make(AstKind.AST_EQUALS, a, b); :}
  | expr:a NOT_EQUALS expr:b                {: RESULT = Ast.make(AstKind.AST_NOT_EQUALS, a, b); :}
  | expr:a SMALLER expr:b                   {: RESULT = Ast.make(AstKind.AST_SMALLER, a, b); :}
  | expr:a SMALLER_OR_EQUAL expr:b          {: RESULT = Ast.make(AstKind.AST_SMALLER_OR_EQUAL, a, b); :}
  | expr:a GREATER expr:b                   {: RESULT = Ast.make(AstKind.AST_GREATER, a, b); :}
  | expr:a GREATER_OR_EQUAL expr:b          {: RESULT = Ast.make(AstKind.AST_GREATER_OR_EQUAL, a, b); :}
  | EXCLAMATION expr:e                      {: RESULT = Ast.make(AstKind.AST_BOOL_NOT, e); :}
  | expr:e AS type_name:tn                  {: RESULT = Ast.makeTypeCast(e, tn); :}
  | expr:e IS type_name:tn                  {: RESULT = Ast.makeTypeCheck(e, tn); :}
  | LEN LPAREN expr:e RPAREN                {: RESULT = Ast.make(AstKind.AST_LEN, e); :}
  | TYPEOF LPAREN expr:e RPAREN             {: RESULT = Ast.make(AstKind.AST_TYPEOF, e); :}
  | INPUT LPAREN optional_expr:oe RPAREN    {: RESULT = Ast.make(AstKind.AST_INPUT, oe); :}
  | LPAREN expr:e RPAREN                    {: RESULT = e; :}
  | scalar:s                                {: RESULT = s; :}
;

optional_expr ::=
    expr:e                                  {: RESULT = e; :}
  | /* %empty */
;

ident ::=
    IDENTIFIER:id                           {: RESULT = Ast.scalar(AstKind.AST_IDENTIFIER, id); :}
;

variable ::=
    ident:i                                 {: RESULT = i; :}
  | array_access:aa                         {: RESULT = aa; :}
;

scalar ::=
    BOOL:b                                  {: RESULT = Ast.scalar(AstKind.AST_BOOL, b); :}
  | FLOAT:f                                 {: RESULT = Ast.scalar(AstKind.AST_FLOAT, f); :}
  | INTEGER:i                               {: RESULT = Ast.scalar(AstKind.AST_INTEGER, i); :}
  | STRING:s                                {: RESULT = Ast.scalar(AstKind.AST_STRING, s); :}
  | array_expr:ae                           {: RESULT = ae; :}
;

type_name ::=
    TYPENAME_ARRAY                          {: RESULT = ScalarType.ARRAY; :}
  | TYPENAME_BOOL                           {: RESULT = ScalarType.BOOLEAN; :}
  | TYPENAME_FLOAT                          {: RESULT = ScalarType.FLOAT; :}
  | TYPENAME_INT                            {: RESULT = ScalarType.INTEGER; :}
  | TYPENAME_STRING                         {: RESULT = ScalarType.STRING; :}
;

array_access ::=
    variable:v LBRACKET optional_expr:oe RBRACKET
                                            {: RESULT = Ast.make(AstKind.AST_ARRAY_ACCESS, v, oe); :}
;

array_expr ::=
    LBRACKET array_expr_value_list:aevl RBRACKET
                                            {: RESULT = Ast.makeArray(aevl); :}
;

array_expr_value_list ::=
    array_expr_value_list:aevl COMMA optional_expr:oe
                                            {: aevl.add(oe); RESULT = aevl; :}
  | optional_expr:oe                        {: RESULT = Ast.makeList(oe); :}
;
